#include "/Engine/Public/Platform.ush"
float2 InputDimention;
float2 OutputDimention;
float2 InvOutputDimention;
Texture2D InputTexture;
RWTexture2D<float4> OutputTexture;
SamplerState SamLinearClamp;
 
namespace Catmul
{ 
    struct Parameter
    {
        float2 OriginSampleCoord;
        float2 Weight[4]; 
        float2 Weight12;
        float2 Offset12;
        
        float2 SamplePos0;
        float2 SamplePos3;
        float2 SamplePos12;
        
        void Initialize(float2 Uv, float2 TexSize, float2 InvTexSize)
        {   
            float2 SamplePos = Uv * TexSize;
            OriginSampleCoord = floor(SamplePos - 0.5f) + 0.5f; 

            float2 f = SamplePos - OriginSampleCoord;
            float2 f2 = f * f;
            float2 f3 = f2 * f;
            
            // Compute the Catmull-Rom weights using the fractional offset that we calculated earlier.
            // These equations are pre-expanded based on our knowledge of where the texels will be located,
            // which lets us avoid having to evaluate a piece-wise function.
            Weight[0] = f * (-0.5f + f * (1.0f - 0.5f * f));
            Weight[1] = 1.0f + f2 * (-2.5f + 1.5f * f);
            Weight[2] = f * (0.5f + f * (2.0f - 1.5f * f));
            Weight[3] = f2 * (-0.5f + 0.5f * f);
            
            // Work out weighting factors and sampling offsets that will let us use bilinear filtering to
            // simultaneously evaluate the middle 2 samples from the 4x4 grid.
            Weight12 = Weight[1] + Weight[2];
            Offset12 = Weight[2] / (Weight[1] + Weight[2]);

            // Compute the final UV coordinates we'll use for sampling the texture
            SamplePos0 = (OriginSampleCoord - 1) * InvTexSize;
            SamplePos3 = (OriginSampleCoord + 2) * InvTexSize;
            SamplePos12 = (OriginSampleCoord + Offset12) * InvTexSize;
        }
    };
    float4 Compute(in Texture2D tex, in SamplerState linearSampler, Parameter param)
    {
        float4 result = 0.0f;
        result += tex.SampleLevel(linearSampler, float2(param.SamplePos0.x, param.SamplePos0.y), 0.0f) * param.Weight[0].x * param.Weight[0].y;
        result += tex.SampleLevel(linearSampler, float2(param.SamplePos12.x, param.SamplePos0.y), 0.0f) * param.Weight12.x * param.Weight[0].y;
        result += tex.SampleLevel(linearSampler, float2(param.SamplePos3.x, param.SamplePos0.y), 0.0f) * param.Weight[3].x * param.Weight[0].y;

        result += tex.SampleLevel(linearSampler, float2(param.SamplePos0.x, param.SamplePos12.y), 0.0f) * param.Weight[0].x * param.Weight12.y;
        result += tex.SampleLevel(linearSampler, float2(param.SamplePos12.x, param.SamplePos12.y), 0.0f) * param.Weight12.x * param.Weight12.y;
        result += tex.SampleLevel(linearSampler, float2(param.SamplePos3.x, param.SamplePos12.y), 0.0f) * param.Weight[3].x * param.Weight12.y;

        result += tex.SampleLevel(linearSampler, float2(param.SamplePos0.x, param.SamplePos3.y), 0.0f) * param.Weight[0].x * param.Weight[3].y;
        result += tex.SampleLevel(linearSampler, float2(param.SamplePos12.x, param.SamplePos3.y), 0.0f) * param.Weight12.x * param.Weight[3].y;
        result += tex.SampleLevel(linearSampler, float2(param.SamplePos3.x, param.SamplePos3.y), 0.0f) * param.Weight[3].x * param.Weight[3].y;

        return result;
    }
}

[numthreads(16, 16, 1)]
void Main(uint3 dispatchThreadID : SV_DispatchThreadID)
{
    if (dispatchThreadID.x >= OutputDimention.x || dispatchThreadID.y >= OutputDimention.y)
        return;
                  
    const float2 Uv = (dispatchThreadID.xy + 0.5f) * InvOutputDimention;

    Catmul::Parameter Param;
    Param.Initialize(Uv, OutputDimention, InvOutputDimention);
    OutputTexture[dispatchThreadID.xy] = Catmul::Compute(InputTexture, SamLinearClamp, Param);
}